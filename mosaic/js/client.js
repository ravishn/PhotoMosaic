(function(screen) {

    'use-strict';

    function mosaic(properties) {
        if (!properties.image) {
            throw new Error('image properties are not passed');
        }
        if (!properties.targetElement) {
            throw new Error('targetElement is not passed in properties');
        }

        this.options = this.extend(this.defaults, properties);

        if (this.options.image.complete) {
            this.process();
        } else {
            this.options.image.onload = this.process.bind(this);
        }
    }

    mosaic.prototype.process = function() {
        this.options.divX = Math.floor(this.options.width / this.options.tileWidth);
        this.options.divY = Math.floor(this.options.height / this.options.tileHeight);
        var context = this.renderImage();
        this.tileCanvas(context);
    };

    /**
     * Extends a Javascript Object
     * @param  {object} destination The object in which the final extended values are saved
     * @param  {object} sources     The objects to be extended
     * @return {}
     */
    mosaic.prototype.extend = function(destination, sources) {
        for (var source in sources) {
            if (sources.hasOwnProperty(source)) {
                destination[source] = sources[source];
            }
        }
        return destination;
    };

    /**
     * The defaults options object
     * @type {Object}
     */
    mosaic.prototype.defaults = {
        'image': null,
        'tileWidth': 8, //this changes the width of each tile
        'tileHeight': 8, //this changes the height of each tile
        'targetElement': null,
        'opacity': 1,
        'width': null,
        'height': null
    };

    /**
     * Renders the image on a canvas before processing the pixels
     * @return {object} Context of the canvas created
     */
    mosaic.prototype.renderImage = function() {
        var options = this.options;
        var canvas = document.createElement('canvas');

        canvas.width = options.tileWidth * options.divX;
        canvas.height = options.tileHeight * options.divY;

        var context = canvas.getContext('2d');
        context.drawImage(options.image, 0, 0, canvas.width, canvas.height);
        return context;
    };

    /**
     * Returns the average color of the canvas.
     * @param  {Array} data     The data received by using the getImage() method
     * @return {Object}         The object containing the RGB value
     */
    mosaic.prototype.getAverageColor = function(data) {
        var i = -4,
            pixelInterval = 5,
            count = 0,
            rgb = {
                r: 0,
                g: 0,
                b: 0
            },
            length = data.length;

        while ((i += pixelInterval * 4) < length) {
            count++;
            rgb.r += data[i];
            rgb.g += data[i + 1];
            rgb.b += data[i + 2];
        }

        // floor the average values to give correct rgb values
        rgb.r = Math.floor(rgb.r / count);
        rgb.g = Math.floor(rgb.g / count);
        rgb.b = Math.floor(rgb.b / count);

        return rgb;
    };


    /**
     * Divides the whole canvas into smaller tiles and finds the average
     * colour of each block. After calculating the average colour, it stores
     * the data into an array.
     *
     * @param context   Context of the canvas
     */
    mosaic.prototype.tileCanvas = function(context) {
        var processedCanvas = document.createElement('canvas');
        var width = processedCanvas.width = context.canvas.width;
        processedCanvas.height = context.canvas.height;

        var processedContext = processedCanvas.getContext('2d');
        var options = this.options;

        var originalImageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);

        for (var i = 0; i < options.divY; i++) {
            for (var j = 0; j < options.divX; j++) {
                var x = j * options.tileWidth,
                    y = i * options.tileHeight;
                var imageData = this.getImageData(x, y, width, originalImageData);
                var averageColor = this.getAverageColor(imageData);
                var color = 'rgba(' + averageColor.r + ',' + averageColor.g + ',' + averageColor.b + ',' + this.options.opacity + ')';
                processedContext.fillStyle = color;
                this.createMosaic(x, y, processedContext);
            }
        }
        this.options.targetElement.appendChild(processedCanvas);
    };

    /**
     * Creates an array of the image data of the tile from the data of whole image
     * @param  {number} startX            x coordinate of the tile
     * @param  {number} startY            y coordinate of the tile
     * @param  {number} width             width of the canvas
     * @param  {object} originalImageData imageData if the whole canvas
     * @return {array}                    Image data of a tile
     */
    mosaic.prototype.getImageData = function (startX, startY, width, originalImageData) {
        var data = [];
        var tileWidth = this.options.tileWidth;
        var tileHeight = this.options.tileHeight;
        for (var x = startX; x < (startX + tileWidth); x++) {
            var xPos = x * 4;
            for (var y = startY; y < (startY + tileHeight); y++) {
                var yPos = y * width * 4;
                data.push(
                    originalImageData.data[xPos + yPos + 0],
                    originalImageData.data[xPos + yPos + 1],
                    originalImageData.data[xPos + yPos + 2],
                    originalImageData.data[xPos + yPos + 3]
                );
            }
        }
        return data;
    };

    /**
     * Creates a block of the mosaic. This is called divX*divY times to create all blocks
     * of the mosaic.
     * @param  {number} x          x coordinate of the block
     * @param  {number} y          y coordinate of the block
     * @param  {object} context    Context of the result canvas
     * @return {}
     */
    mosaic.prototype.createMosaic = function(x, y, context) {

        var tileWidth = this.options.tileWidth;
        var tileHeight = this.options.tileHeight;

            var height = tileHeight;
            var width = tileWidth;
            context.beginPath();
            context.rect(x, y, width, height);
            context.closePath();
            context.fill();
    };

    screen.photoMosaic = mosaic;
}(window));
